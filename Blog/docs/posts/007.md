Dans cette partie, nous allons simuler une vraie collaboration en entreprise.
Vous allez travailler en binôme sur le même dépôt et volontairement créer des conflits pour apprendre à les résoudre proprement.

## Mise en place de l'exercice
### Étape 1 – Donner accès à votre partenaire
1. Sur GitHub → Settings
2. Collaborators
3. Ajouter le GitHub de votre binôme

Chaque étudiant clone ensuite le dépôt de l’autre :
``` bash
git clone <url-du-depot-du-partenaire>
cd nom-du-projet
``` 

### Étape 2 – Provoquer un conflit
Les conflits arrivent lorsque deux personnes modifient la même ligne d’un fichier.
Exercice
1. Choisissez un fichier commun (ex: README.md)
2. Étudiant A modifie une phrase
3. Étudiant B modifie la même phrase
4. Les deux font :
``` bash
git add .
git commit -m "[Perla][ISICG-574] Modification du README"
git push
``` 

*Celui qui pousse en second aura une erreur.*

### Étape 3 – Comprendre `git fetch`
Pour intégrer des changements distants, il est recommandé de faire :
``` bash
git fetch origin
```

**Différence importante :**
| Commande    | Ce qu’elle fait                                        |
| ----------- | ------------------------------------------------------ |
| `git fetch` | Télécharge les changements sans modifier votre branche |
| `git pull`  | Fait un `fetch` + `merge` automatique                  |

Après un fetch, vous pouvez voir les différences :
``` bash
git log HEAD..origin/main --oneline
```

#### Merge vs Rebase
##### `git merge`
``` bash
git merge main
```

- Crée un commit de merge
- Conserve l’historique exact
- Historique non linéaire

**Historique linéaire**

Un historique linéaire ressemble à ceci :
```
A --- B --- C --- D --- E
```
Chaque commit a un seul parent, on peut suivre l’histoire en ligne droite. C’est souvent le résultat d’un git rebase

**Historique non linéaire avec git merge**
Imaginons :
- Alice travaille sur main
- Bob crée une branche feature

Situation :
```
A --- B --- C  (main)
       \
        D --- E  (feature)
```

Quand Bob fait :
``` bash
git merge feature
```

Git crée un commit de merge :
```
A --- B --- C -------- F  (main)
       \              /
        D --- E ------
```

Le commit F a deux parents : C et E. C’est cela qui rend l’historique non linéaire.

Visualisation avec git log --graph:
``` bash
git log --oneline --graph --all
```

Avantage :
- Historique fidèle
- Pas de réécriture

Inconvénient :
- Historique parfois difficile à lire

##### `git rebase`
``` bash
git rebase -i main
```
- Rejoue vos commits au-dessus de la branche distante
- Produit un historique linéaire

```
A---B---C---D'---E'
```

Avantage :
- Historique propre et linéaire
- Plus lisible

Inconvénient :
- Réécriture de l’historique ***(on s'en fiche!!)***

#### Debugging et structure de l’historique

`git merge` conserve un historique exact : il ne réécrit rien et ajoute un commit de fusion qui relie deux branches. L’historique devient cependant non linéaire, avec des commits ayant plusieurs parents, ce qui peut compliquer le debugging en production. Un bug peut provenir de la branche fusionnée, de la branche principale, ou de la résolution de conflit.

Avec un `rebase`, l’historique est linéaire et chaque commit représente un changement isolé. Cela rend plus simple :

- Revenir à un point précis
- Tester un état du projet
- Identifier rapidement l’introduction d’un bug

En résumé : `merge` privilégie la fidélité historique, `rebase` privilégie la lisibilité et l’efficacité en cas d’incident, ce qui est souvent plus important en production.

### Étape 4 – Rebase interactive et résolution d’un conflit
#### Activer le rebase interactif

``` bash
git rebase -i origin/main
```

Git ouvre une liste de commits :
```
pick d34db33 Commit [Perla][ISICG-574] modifiant README
pick a1b2c3f Commit [Perla][ISICG-574] modifiant README
pick f5e6d7a Commit [Perla][ISICG-574] ajout d'une fonction
```

`pick` signifie “garder ce commit tel quel”. Ces ligne peut être aussi supprimer pour les enlever du rebase, comme un "cherry pick".  

#### Inspecter et résoudre le conflit commit par commit
Lorsque Git s’arrête sur un commit en conflit :
Visualisez les changements :
```
git status
git diff
```
Éditez le fichier pour résoudre le conflit. Les marqueurs `<<<<<<<`, `=======`, `>>>>>>>` montrent les différences.
Une fois résolu :
``` bash
git add README.md
git rebase --continue
```
Git passe au commit suivant et répète le processus si nécessaire.

**Interruption d’un rebase :**
Si vous êtes bloqué :

``` bash
git rebase --abort
```

Cela nous ramène à l’état initial.

### Étape 5 – Push après un rebase
Après un rebase, l’historique local a changé. Un `git push` classique échouera: 
```
Updates were rejected because the tip of your current branch is behind
```

#### Ne PAS utiliser `--force`

``` bash
git push --force
```
- Écrase l’historique distant
- Peut supprimer le travail d’un collègue
- Irréversible si non sauvegardé

#### Utiliser `--force-with-lease`

``` bash
git push --force-with-lease
```
Git vérifie que la branche distante n’a pas changé depuis votre dernier fetch. Si quelqu’un a poussé entre-temps → le push échoue. C’est le comportement recommandé en équipe.

## References
- [When do you use Git rebase instead of Git merge?](https://stackoverflow.com/questions/804115/when-do-you-use-git-rebase-instead-of-git-merge)
- [git push --force-with-lease vs. --force](https://stackoverflow.com/questions/52823692/git-push-force-with-lease-vs-force)
- [git push](https://git-scm.com/docs/git-push)